'use strict';

var events = require('events');
var path = require('path');
var process = require('process');
var cheerio = require('cheerio');
var Parser = require('htmlparser2');
var fs = require('fs');
var util = require('util');
var chalk$1 = require('chalk');
require('ansi-regex');
var fastXmlParser = require('fast-xml-parser');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var process__default = /*#__PURE__*/_interopDefaultLegacy(process);
var cheerio__namespace = /*#__PURE__*/_interopNamespace(cheerio);
var Parser__default = /*#__PURE__*/_interopDefaultLegacy(Parser);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

/**
 * @fileoverview The SVG -> AST parser.
 * This handles turning an SVG source into an AST representing it.
 * It uses htmlparser2 to parse the source, which it gathers from either
 *   a string or a file.
 */

/**
 * Parses an SVG source into an AST
 * @param {String} source The source to parse
 * @returns {AST} The parsed AST
 */
function parseSource(source) {
    return normalizeAST(
        sourceToAST(source),
        source
    );
}

/**
 * Clones an AST by re-parsing it's source
 * @param {AST} ast The AST to clone
 * @returns {AST} The cloned AST
 */
function clone(ast) {
    // @ts-ignore
    return parseSource(ast.source);
}

/**
 * Parses the content of a file into an AST
 * @param {String} file The path of the file in question
 * @returns {Promise<AST>} The parsed AST
 */
function parseFile(file) {
    const filePath = path__default["default"].isAbsolute(file)
        ? file
        : path__default["default"].join(process__default["default"].cwd(), file);
    return new Promise((res, rej) => {
        fs__default["default"].readFile(
            filePath,
            "utf8",
            (err, data) => {
                if (err) {
                    return rej(err);
                }
                try { return res(parseSource(data)); }
                catch (e) { return rej(e); }
            }
        );
    });
}

/**
 * @typedef {Object<string,string>} Attributes
 */
/**
 * @typedef Node
 * @property {String} type The type of node
 * @property {Node} next The next sibling
 * @property {Node} prev The previous sibling
 * @property {Node} parent The parent of the node
 * @property {Number} startIndex The string index at which the element starts
 * @property {Number} endIndex The string index at which the element ends
 * @property {Number} lineNum The line number at which the element starts
 * @property {Number} columnNum The index in the line at which the element starts
 * 
 * @property {Attributes} [attribs] An object of attributes on the Node
 * @property {AST} [children] The children of the Node
 * @property {String} [data] If type==="text", the content of the Node
 * @property {String} [name] If type!=="text", the tag name
 */
/**
 * @typedef ASTShape
 * @property {String} source The source that generated the AST
 * 
 * @typedef {Node[] & ASTShape} AST
 * An AST representing an SVG document (or a list of children).
 */

/**
 * Parses an SVG source code into an AST.
 * @param {String} source 
 * @returns {AST} The parsed AST
 */
function sourceToAST(source) {
    // @ts-ignore
    const outp = Parser__default["default"].parseDOM(source, {
        withStartIndices: true,
        withEndIndices: true,
        xmlMode: true,
    });
    return outp;
}

/**
 * Normalizes a Node to the format we want.
 * Currently translates the startIndex to a line number+index.
 * == MODIFIES THE NODE IN-PLACE! ==
 * @param {Node} node The node to normalize
 * @param {String} source The string the AST was generated from
 */
function normalizeNode(node, source) {
    // calculate the distance from node start to line start
    const lineStart = (
        source.lastIndexOf("\n", node.startIndex + 
            // make sure newline text nodes are set to start on the proper line
            ((node.type === "text" && node.data.startsWith("\n")) ? -1 : 0))
    ) + 1;
    node.columnNum = node.startIndex - lineStart;

    // calculate the line number
    let numLines = 0;
    let columnNum = lineStart;
    while ((columnNum = source.lastIndexOf("\n", columnNum - 1)) !== -1 && columnNum > 0) {
        ++numLines;
    }
    node.lineNum = numLines;
    return node;
}

/**
 * Normalizes the AST returned by htmlparser2 to the format we want.
 * Currently translates the startIndex to a line number+index.
 * == MODIFIES THE AST IN-PLACE! ==
 * @param {AST} ast The AST to normalize
 * @param {String} source The source the AST was generated from
 * @returns {AST} The normalized AST
 */
function normalizeAST(ast, source) {
    const handleNode = node => {
        normalizeNode(node, source);
        if (node.children) {
            node.children.forEach(handleNode);
        }
    };
    ast.forEach(handleNode);
    // @ts-ignore
    ast.source = source;
    return ast;
}

/**
 * @fileoverview Utilities for the CLI.
 */

const supportsColor = chalk$1.supportsColor &&
    !("NO_COLOR" in process__default["default"].env) &&
    !("SVGLINT_NO_COLOR" in process__default["default"].env);

let chalk = supportsColor ? new chalk$1.Chalk() : new chalk$1.Chalk({level: 0});

process__default["default"].stdout.columns || 80;
Object.freeze({
    // logs
    "debug": Object.freeze({
        symbol: "d",
        color: chalk.gray.dim.bold,
    }),
    "log": Object.freeze({
        symbol: "i",
        color: chalk.blue.bold,
    }),

    // lintings
    "linting": Object.freeze({
        symbol: null,
        color: chalk.gray.dim,
    }),
    "success": Object.freeze({
        symbol: "âœ“",
        color: chalk.green.bold,
    }),
    "warn": Object.freeze({
        symbol: "!",
        color: chalk.yellow.bold,
    }),
    "error": Object.freeze({
        symbol: "x",
        color: chalk.red.bold,
    }),
    "exception": Object.freeze({
        symbol: "!!!",
        color: chalk.bgRed.bold,
    }),
});

/**
 * @fileoverview Exposes the logger we should use for displaying info.
 * If called using the JS API, this will be `console` with prefixes.
 * If called using the CLI, this will be our own custom logger.
 */

const CONSOLE_COLORS = Object.freeze({
    debug: chalk.dim.gray,
    log: chalk.blue,
    warn: chalk.yellow,
    error: chalk.red,
});
const LEVELS = Object.freeze({
    debug: 0,
    log: 1,
    warn: 2,
    error: 3,
});
const METHODS = ["debug", "log", "warn", "error"];

// Logger-global variables
let isCLI = false;
let level = LEVELS.log;

// create a prefixing & colorizing wrapper around console for use in non-CLIs
const wrappedConsole = Object.create(console);
METHODS.forEach(method => {
    const color = CONSOLE_COLORS[method]
        ? CONSOLE_COLORS[method]
        : v => v;
    wrappedConsole[method] = (prefix, args) => {
        // eslint-disable-next-line no-console
        console[method].apply(console, [color("["+prefix+"]"), ...args]);
    };
});

// create a simple collector & emitter of messages for use in CLIs
class CliConsole extends events.EventEmitter {
    constructor() {
        super();
        /** The messages that have been emitted so far.
         * @type {Array<{ prefix: String, args: Array, type: String }>} */
        this.messages = [];
        METHODS.forEach(method => {
            this[method] = (prefix, args) => {
                const msg = {
                    prefix: prefix.replace(/^SVGLint ?/, ""),
                    args,
                    type: method,
                };
                this.messages.push(msg);
                this.emit("msg", msg);
            };
        });
    }
}
CliConsole.prototype.EVENTS = METHODS;
const cliConsole = new CliConsole();

const Logger = function(prefix) {
    prefix = "SVGLint" + (prefix ? " " + prefix : "");
    const logger = {};
    METHODS.forEach(method => {
        logger[method] = function(...args) {
            if (level > LEVELS[method]) { return; }
            if (isCLI) {
                cliConsole[method].call(cliConsole, prefix, args);
            } else {
                wrappedConsole[method].call(wrappedConsole, prefix, args);
            }
        };
    });
    return logger;
};
Logger.cliConsole = cliConsole;
Logger.setCLI = value => { isCLI = value; };
Logger.setLevel = value => { level = value; };
Logger.LEVELS = LEVELS;
Logger.colorize = supportsColor ?
    value => util.inspect(value, true, 2, true) : value => value;

/**
 * @fileoverview The object that rules use to report errors, warnings and messages.
 */

/** @typedef {import("./parse.js").AST} AST */
/** @typedef {import("./parse.js").Node} Node */

/**
 * @typedef {Object} Result
 * @property {String} message The message as a single string, suitable for human consumption
 * @property {String} reason The message as a single string
 * @property {"error"|"warn"|"exception"} type The type of result
 * @property {String} [stacktrace] If Result is related to a node, a human-suitable string showing the related part of the file
 * @property {number} [line] If Result is related to a node, the related line in the file
 * @property {number} [column] If Result is related to a node, the related column in the file
 * @property {any[]} _message The original message, as given by the rule
 * @property {Node} [_node] If Result is related to a node, the related node
 * @property {AST} [_ast] If Result is related to a node, the related AST
 */

/**
 * Generates a Result from the arguments given to .error()/.warn()/.log().
 * Mostly involves formatting the message that should be shown when logged.
 * @param {any[]|any} message The message of the result, in console.log format
 * @param {"error"|"warn"|"exception"} type The type of message
 * @param {Node|Cheerio} [node] If the error is related to a node, the related node
 * @param {AST} [ast] If the error is related to a node, the related AST
 * @returns {Result}
 */
function generateResult(message, type, node, ast) {
    const _message = message instanceof Array ? message : [message];
    const outp = {
        message: message,
        reason: message,
        _message,
        _node: node,
        _ast: ast,
        type,
    };
    if (message instanceof Error) {
        outp.message = message.stack || message.toString();
        outp.reason = message.toString();
    }
    if (node) {
        // @ts-ignore
        outp.message += `\n  At node ${chalk.bold("<"+node.name+">")} (${node.lineNum}:${node.columnNum})`;
        outp.reason += " at node <"+node.name+">";
        outp.line = node.lineNum;
        outp.column = node.columnNum;
    }
    // @ts-ignore
    return outp;
}

class Reporter extends events.EventEmitter {
    /**
     * @param {String} name The name of this reporter
     */
    constructor(name) {
        super();
        this.name = name;
        this.logger = Logger(`rprt:${this.name}`);
        /** @type {Result[]} */
        this.messages = [];

        this.hasExceptions = false;
        this.hasWarns = false;
        this.hasErrors = false;
    }

    /**
     * Reports that an exception occurred during rule processing.
     * This doesn't change the current linting result, but is important to show
     *   to users as it indicates that the linting result cannot be trusted.
     * @param {Error} e The exception that occurred.
     */
    exception(e) {
        this.logger.debug("Exception reported:", e);
        this.emit("exception", e);
        this.hasExceptions = true;
        this.messages.push(generateResult(e, "exception"));
    }

    /**
     * Reports that an error was found during linting.
     * @param {any[]|any} message The message of the result, in console.log format
     * @param {Node|Cheerio} [node] If the error is related to a node, the related node
     * @param {AST} [ast] If the error is related to a node, the AST of the file
     */
    error(message, node, ast) {
        this.logger.debug("Error reported:", JSON.stringify(message), !!node);
        const result = generateResult(message, "error", node, ast);
        this.hasErrors = true;
        this.messages.push(result);
    }

    /**
     * Reports that a warning was found during linting.
     * @param {any[]|any} message The message of the result, in console.log format
     * @param {Node|Cheerio} [node] If the warning is related to a node, the related node
     * @param {AST} [ast] If the warning is related to a node, the AST of the file
     */
    warn(message, node, ast) {
        this.logger.debug("Warn reported:", JSON.stringify(message), !!node);
        const result = generateResult(message, "warn", node, ast);
        this.hasWarns = true;
        this.messages.push(result);
    }
}

/**
 * @fileoverview The main linting file.
 * This is the object responsible for the actual linting of each file.
 * Each instance represents a single file being linted, including results and
 *   current state.
 * It receives the parsed AST and rules from ../svglint.js, and then runs each
 *   rule and gathers the results.
 */

/** @typedef {import("./parse.js").AST} AST */
/** @typedef {import("./parse.js").Node} Node */
/** @typedef {import("../svglint.js").NormalizedRules} NormalizedRules */

const STATES = Object.freeze({
    "ignored": "ignored",
    "linting": "linting",
    "success": "success",
    "warn":    "warn",
    "error":   "error",
});

/**
 * Represents a single file that is being linted.
 * Contains the status and potential result of the linting.
 * @event rule Emitted when a rule is finished
 * @event done Emitted when the linting is done
 */
class Linting extends events.EventEmitter {
    /**
     * Creates and starts a new linting.
     * @param {String} file The file to lint
     * @param {AST} ast The AST of the file
     * @param {NormalizedRules} rules The rules to lint by
     */
    constructor(file, ast, rules) {
        super();
        /** The AST of the file */
        this.ast = ast;
        /** The rules we use for linting */
        this.rules = rules;
        /** The path to the file */
        this.path = file;
        /** The current state of the linting */
        this.state = STATES.linting;
        /** If false, the linting has at least one rule that threw when executing */
        this.valid = true;
        /** The name used for logging/human consumption */
        this.name = file
            ? path__default["default"].relative(process__default["default"].cwd(), file)
            : "API";
        /** The Reporters for each rule we've linted
         * @type Object<string,Reporter|Reporter[]> */
        this.results = {};
        /** The logger used to show debugs */
        this.logger = Logger(`lint:${this.name}`);

        this.lint();
    }

    /**
     * Starts the linting.
     * Errors from rules are safely caught and logged as exceptions from the rule.
     */
    lint() {
        this.state = STATES.linting;

        // keep track of when every rule has finished
        const ruleNames = Object.keys(this.rules);
        if (ruleNames.length === 0) {
            this.logger.debug("No rules to lint, finishing");
            this.state = STATES.success;
            Promise.resolve()
                .then(() => this.emit("done"));
            return;
        }
        this.activeRules = ruleNames.length;

        this.logger.debug("Started linting");
        this.logger.debug("  Rules:", ruleNames);

        // start every rule
        ruleNames.forEach(ruleName => {
            const ast = clone(this.ast);
            const cheerioParsed = cheerio__namespace.load(
                "<root></root>",
                { xmlMode: true }
            )("root")
                // @ts-ignore
                .append(ast);
            /**
             * Executes a rule function.
             * @param {Function} rule The loaded rule
             * @param {String} reporterName The name to give the reporter
             * @param {Function} onDone Function to call once the rule is done
             */
            const execute = (rule, reporterName, onDone) => {
                // gather results from the rule through a reporter
                const reporter = this._generateReporter(reporterName);
                // execute the rule, potentially waiting for async rules
                // also handles catching errors from the rule
                Promise.resolve()
                    .then(() => rule(reporter, cheerioParsed, ast, { filepath: this.path }))
                    .catch(e => reporter.exception(e))
                    .then(() => onDone(reporter));
            };

            /** @type {Function|Function[]} */
            const rule = this.rules[ruleName];
            if (rule instanceof Array) {
                /** @type {Reporter[]} */
                const results = [];
                let activeRules = rule.length;
                rule.forEach((r, i) => {
                    execute(r, `${ruleName}-${i+1}`, result => {
                        results[i] = result;
                        if (--activeRules <= 0) {
                            this._onRuleFinish(ruleName, results);
                        }
                    });
                });
                if (rule.length === 0) {
                    Promise.resolve()
                        .then(() => {
                            this._onRuleFinish(ruleName, this._generateReporter(ruleName));
                        });
                    this.logger.debug("Rule had no configs", Logger.colorize(ruleName));
                }
            } else {
                execute(rule, ruleName, result => {
                    this._onRuleFinish(ruleName, result);
                });
            }
        });
    }

    /**
     * Handles a rule finishing.
     * @param {String} ruleName The name of the rule that just finished
     * @param {Reporter|Reporter[]} reporter The reporter containing rule results
     * @emits rule
     * @private
     */
    _onRuleFinish(ruleName, reporter) {
        this.logger.debug("Rule finished", Logger.colorize(ruleName));
        this.emit("rule", {
            name: ruleName,
            result: reporter,
        });
        this.results[ruleName] = reporter;

        --this.activeRules;
        if (this.activeRules === 0) {
            this.state = this._calculateState();
            this.logger.debug("Linting finished with status", Logger.colorize(this.state));
            this.emit("done");
        }
    }

    /**
     * Calculates the current state from this.results.
     * @returns One of the valid states
     */
    _calculateState() {
        let state = STATES.success;
        for (let k in this.results) {
            const result = this.results[k];
            if (result instanceof Array) {
                if (result.some(res => res.hasErrors || res.hasExceptions)) {
                    return STATES.error;
                }
                if (result.some(res => res.hasWarns)) {
                    state = STATES.warn;
                }
            } else {
                if (result.hasErrors || result.hasExceptions) {
                    return STATES.error;
                }
                if (result.hasWarns) {
                    state = STATES.warn;
                }
            }
        }
        return state;
    }

    /**
     * Generates a Reporter for use with this file.
     * Remember to call .done() on it.
     * @param {String} ruleName The name of the rule that this reporter is used for
     * @returns {Reporter} The generated reporter
     * @private
     */
    _generateReporter(ruleName) {
        const reporter = new Reporter(ruleName);
        reporter.once("exception", () => {
            this.valid = false;
        });
        return reporter;
    }
}
Linting.STATES = Linting.prototype.STATES = STATES;

function __variableDynamicImportRuntime1__(path) {
  switch (path) {
    case '../rules/attr.js': return Promise.resolve().then(function () { return attr$1; });
    case '../rules/custom.js': return Promise.resolve().then(function () { return custom$1; });
    case '../rules/elm.js': return Promise.resolve().then(function () { return elm$1; });
    case '../rules/valid.js': return Promise.resolve().then(function () { return valid$1; });
    default: return new Promise(function(resolve, reject) {
      (typeof queueMicrotask === 'function' ? queueMicrotask : setTimeout)(
        reject.bind(null, new Error("Unknown variable dynamic import: " + path))
      );
    })
   }
 }

/**
 * @fileoverview Turns a rule name into a module import.
 * Can be extended to use a cache if we have to do heavier processing when
 *   loading a rule.
 * Currently NodeJS' import cache is just fine.
 */

/**
 * @typedef RuleModule
 * @property {Function} generate When given a config, returns a linting function
 */

/**
 * Finds and imports a rule from its name.
 * If the rule is named in the format "a/b" then the rule will be loaded from
 *   the package "svglint-plugin-a/b".
 * If the rule name does not contain a slash then it will be loaded from the
 *   built-in SVGLint rules.
 * @param {String} ruleName The name of the rule
 * @returns {Promise<RuleModule>} Resolves to the function exported by the rule if found.
 */
async function ruleLoader(ruleName) {
    const fileName = ruleName.endsWith(".js")
        ? ruleName
        : ruleName + ".js";
    const isExternal = ruleName.includes("/");
    let module;
    if (isExternal) {
        module = await (function (t) { return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(t)); }); })(`svglint-plugin-${ruleName}`);
    } else {
        module = await __variableDynamicImportRuntime1__(`../rules/${fileName.slice(0, -3)}.js`);
    }
    return module.default;
}

/**
 * @fileoverview The SVGLint entry file.
 * This is the publicly exposed JS API, which the CLI also uses.
 * It exposes .lintSource() and .lintFile().
 * Main responsibility is handling the consumer<->Linting communication,
 *   and converting the user-provided config into an object of rules.
 */
const logger$4 = Logger("");

/** @typedef {import("./lib/parse.js").AST} AST */
/** @typedef {import("./lib/rule-loader.js").RuleModule} RuleModule */
/** @typedef {import("./rules/elm.js").ElmConfig} ElmConfig */
/** @typedef {import("./rules/attr.js").AttrConfig} AttrConfig */
/** @typedef {import("./rules/custom.js").CustomConfig} CustomConfig */

/**
 * @typedef RulesConfig
 * An object with each key representing a rule name, and each value representing
 *   a rule config.
 * If the rule config is set to `false`, then the rule is disabled (useful for
 *   e.g. overwriting presets).
 * @property {ElmConfig} [elm={}]
 * @property {Array<AttrConfig>} [attr=[]]
 * @property {Array<CustomConfig>} [custom=[]]
 */
/**
 * @typedef {Object<string,Function|Function[]>} NormalizedRules
 * The RulesConfig after being normalized - each function is a rule.
 */
/**
 * @typedef {String[]} IgnoreList
 * An array of strings, each of which is a blob that represents files to ignore.
 * If any blob matches a file, the file is not linted.
 */
/**
 * @typedef Config
 * @property {RulesConfig} [rules={}] The rules to lint by
 * @property {IgnoreList} [ignore=[]] The blobs representing which files to ignore
 */
/**
 * @typedef NormalizedConfig
 * @property {NormalizedRules} rules The rules to lint by
 * @property {IgnoreList} ignore The blobs representing which files to ignore
 */

/** @type Config */
const DEFAULT_CONFIG = Object.freeze({
    useSvglintRc: true,
    rules: { valid: true },
    ignore: [],
});

/**
 * Normalizes a user-provided RulesConfig into a NormalizedRules.
 * Figures out which rules should be kept, and calls their generator with the
 *   user-provided config. The returned function is the actual linting func.
 * @param {RulesConfig} rulesConfig The user-provided config
 * @returns {Promise<NormalizedRules>} Resolves to the normalized rules
 */
async function normalizeRules(rulesConfig) {
    /** @type {NormalizedRules} */
    const outp = {};
    const promises = Object.keys(rulesConfig)
        // make sure no disabled rules are allowed in
        .filter(k => rulesConfig[k] !== false)
        // then convert each rule config into a rule func
        .map(
            async (ruleName) => {
                /** @type {RuleModule} */
                let loadedRule;
                try {
                    loadedRule = await ruleLoader(ruleName);
                } catch (e) {
                    logger$4.warn(`Unknown rule "${ruleName}".`);
                    return;
                }

                // handle the case where there are multiple configs for a single rule
                const config = rulesConfig[ruleName];
                if (config instanceof Array) {
                    /** @type {Array} */
                    outp[ruleName] = config.map(
                        config => loadedRule.generate(config)
                    );
                } else {
                    outp[ruleName] = loadedRule.generate(config);
                }
            }
        );
    await Promise.all(promises);
    return outp;
}

/**
 * Normalizes a user-provided config to make sure it has every property we need.
 * Also handles merging with defaults.
 * @param {Config} config The user-provided config
 * @returns {Promise<NormalizedConfig>} Resolves to the normalized config
 */
async function normalizeConfig(config) {
    const defaulted = Object.assign({},
        DEFAULT_CONFIG,
        config,
    );
    defaulted.rules = Object.assign({}, DEFAULT_CONFIG.rules, config.rules);
    /** @type NormalizedConfig */
    const outp = {
        rules: await normalizeRules(defaulted.rules),
        ignore: defaulted.ignore,
    };
    return outp;
}

/**
 * The main function. Lints the provided AST using the user-provided config.
 * @param {String} file The file we are linting
 * @param {AST} ast The AST to lint
 * @param {Config} config The user-provided config to lint by
 * @returns {Promise<Linting>} Resolves to the linting that represents the result
 */
async function lint(file, ast, config) {
    if (!ast.length && ast.source.trim() !== "") {
        throw new Error(`Unable to parse SVG from ${file || "API"}:
${ast.source}`);
    }
    const conf = await normalizeConfig(config);
    return new Linting(file, ast, conf.rules);
}

var svglint = {
    /**
     * Lints a single SVG string.
     * The function returns before the Linting is finished.
     * You should listen to Linting.on("done") to wait for the result.
     * @param {String} source The SVG to lint
     * @param {Config} [config={}] The config to lint by
     * @return {Promise<Linting>} Resolves to the Linting that represents the result
     */
    async lintSource(source, config={}) {
        const ast = parseSource(source);
        return lint(null, ast, config);
    },

    /**
     * Lints a single file.
     * The returned Promise resolves before the Linting is finished.
     * You should listen to Linting.on("done") to wait for the result.
     * @param {String} file The file path to lint
     * @param {Config} [config={}] The config to lint by
     * @returns {Promise<Linting>} Resolves to the Linting that represents the result
     */
    async lintFile(file, config={}) {
        const ast = await parseFile(file);
        return lint(file, ast, config);
    }
};

const logger$3 = Logger("rule:attr");

/** @typedef {import("../lib/reporter.js")} Reporter */
/** @typedef {import("../lib/parse.js").AST} AST */
/** @typedef {import("../lib/parse.js").Node} Node */

/**
 * @typedef {Object<string,string|string[]|boolean|RegExp>} AttrConfig
 *
 * The key represents the attribute name. The value has the following meanings:  
 * - `{Boolean}` If true, the attr must exist. If false, it must not exist.  
 * - `{String}` The attr value must match this exactly. It must also exist.
 * - `{RegExp}` The attr value must match the regex.
 * - `{Array<String>}` The attr value must be one of these. It must also exist.
 * 
 * The following special configs are allowed:
 * - `{ "rule::selector": {String} }` Default "*". The matching elements must fulfill the other configs.
 * - `{ "rule::whitelist": {Boolean} }` Default `false`. If true, no other attributes can exist than those specified by the other configs.
 * - `{ "rule::order": {Array<String> | Boolean} }` Default `null`. As array, attributes must be defined in the provided order. As `true`, attributes must be defined in alphabetical order.
 * - `{ "<attribute>?": {Boolean|String|RegExp|Array<String>} }` Appending a `?` to an attribute name will make that attribute optional, and it will not error if it is missing when `rule::whitelist` is set.
 */

/**
 * Workflow:
 * 1. Find all elements matching the selector.
 * 2. For each element:
 *   - Go through every rule in the config
 *     - If their attribute must exist, check that it does
 *   - Go through every attribute on the element
 *     - If it has a config:
 *       - If allowed, remove it from the attr list
 *       - If disallowed, error and remove it from the attr list
 *   - If whitelist is true, error if there are non-optional attributes left
 */

const SPECIAL_ATTRIBS = ["rule::selector", "rule::whitelist", "rule::order"];

const OPTIONAL_SUFFIX = "?";

const isAttrOptional = (attr) => attr.endsWith(OPTIONAL_SUFFIX);

/**
 * Executes on a single element.
 * @param {Cheerio} $elm The cheerio element to execute on
 * @param {AttrConfig} config The config to execute
 * @param {Reporter} reporter The rule reporter
 * @param {AST} ast The AST we are executing on
 */
function executeOnElm($elm, config, reporter, ast) {
    // @ts-ignore
    const attrs = Object.assign({}, $elm.attribs);
    // check that all attributes that must exist do so
    Object.keys(config).forEach(
        attrib => {
            // do nothing with special configs
            if (SPECIAL_ATTRIBS.includes(attrib)) { return; }
            // do nothing with optional attributes
            if (isAttrOptional(attrib)) { return; }
            // if defined and not false it must exist
            if (config[attrib] && !(attrib in attrs)) {
                reporter.error(
                    `Expected attribute '${attrib}', didn't find it`,
                    $elm,
                    ast
                );
            }
        }
    );

    if (config["rule::order"]) {
        const attributes = Object.keys(attrs);
        if (attributes.length > 0) {
            let order;
            if (config["rule::order"] === true) {
                // alphabetical ordering
                order = attributes.slice();
                order.sort();
            } else {
                order = config["rule::order"];
            }

            let prevIndex = order.indexOf(attributes[0]);
            for (let i = 1; i < attributes.length; i++) {
                const index = order.indexOf(attributes[i]);
                if (index === -1) {
                    // this attribute doesn't need ordering, ignore it
                    return;
                }

                if (prevIndex !== -1 && index < prevIndex) {
                    reporter.error(
                        `Wrong ordering of attributes, found "${
                            attributes.join(", ")}", expected "${order.join(", ")}"`,
                        $elm,
                        ast
                    );
                    break;
                }
                prevIndex = index;
            }
        }
    }

    // check that all configs are met
    Object.keys(attrs).forEach(
        attrib => {
            const value = attrs[attrib];
            const expected = typeof config[attrib] !== "undefined" ? config[attrib] : config[`${attrib}${OPTIONAL_SUFFIX}`];
            let handled = false;
            // check each type
            switch (typeof expected) {
                case "boolean":
                    handled = true;
                    if (expected === false) {
                        reporter.error(
                            `Attribute '${attrib}' is disallowed`,
                            $elm,
                            ast
                        );
                    }
                    break;
                case "string":
                    handled = true;
                    if (value !== expected) {
                        reporter.error(
                            `Expected attribute '${attrib}' to be "${expected}", was "${value}"`,
                            $elm,
                            ast
                        );
                    }
                    break;
                case "object":
                    if (expected instanceof Array) {
                        handled = true;
                        if (!expected.includes(value)) {
                            reporter.error(
                                `Expected attribute '${attrib}' to be one of ${
                                    JSON.stringify(expected)
                                }, was "${value}"`,
                                $elm,
                                ast
                            );
                        }
                    } else if (expected instanceof RegExp) {
                        handled = true;
                        if (!expected.test(value)) {
                            reporter.error(
                                `Expected attribute '${attrib}' to match ${expected}, was "${value}"`,
                                $elm,
                                ast
                            );
                        }
                    } else {
                        reporter.warn(
                            `Unknown config for attribute '${attrib}' (${
                                JSON.stringify(expected)
                            }), ignoring`,
                            $elm,
                            ast
                        );
                    }
                    break;
            }

            // if we handled the attribute (i.e. we had a config for it)
            // then remove it from our attribute list
            if (handled) {
                delete attrs[attrib];
            }
        }
    );

    if (config["rule::whitelist"]) {
        const remaining = Object.keys(attrs).filter((attr) => !isAttrOptional(attr));

        if (remaining.length) {
            reporter.error(
                `Found extra attributes ${JSON.stringify(remaining)} with whitelisting enabled`,
                $elm,
                ast
            );
        }
    }
}

var attr = {
    /**
     * Generates a linting function from a config
     * @param {AttrConfig} config 
     */
    generate(config) {
        /**
         * Performs the linting according to the previously passed config.
         * @param {Reporter} reporter The reporter to report warnings/errors to
         * @param {Cheerio} $ A cheerio representation of the document
         * @param {AST} ast The underlying AST representation of the document.
         *                  This should be given to Reporter when warning/erroring with a node.
         */
        return function AttrRule(reporter, $, ast) {
            logger$3.debug("Called", config);

            // find all elements that match the selector and execute on them
            const selector = config["rule::selector"] || "*";
            const $elms = $.find(selector).toArray();
            logger$3.debug("Found elms for selector", selector, $elms.length);
            $elms.forEach($elm => executeOnElm($elm, config, reporter, ast));
        };
    }
};

var attr$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': attr
});

const logger$2 = Logger("rule:custom");

/** @typedef {import('cheerio').Cheerio<import('domhandler').Document>} Cheerio */
/** @typedef {import("../lib/reporter.js")} Reporter */
/** @typedef {import("../lib/parse.js").AST} AST */
/** @typedef {import("../lib/parse.js").Node} Node */
/** @typedef {{ filepath: string }} Info */

/**
 * @callback CustomRule
 * @param {Reporter} reporter The reporter to report to
 * @param {Cheerio} $ A cheerio representation of the document
 * @param {AST} ast The AST of the document, which we should pass to reporter
 * @param {Info} info Info related to the current file being linted
 */
/**
 * @typedef {CustomRule} CustomConfig
 * The function will be executed as if though it was a rule.
 */

var custom = {
    /**
     * Generates a linting function from a config
     * @param {CustomConfig} config
     */
    generate(config) {
        /**
         * Performs the linting according to the previously passed config.
         * @param {Reporter} reporter The reporter to report warnings/errors to
         * @param {Cheerio} $ A cheerio representation of the document
         * @param {AST} ast The underlying AST representation of the document.
         *                  This should be given to Reporter when warning/erroring with a node.
         * @param {Info} info Info related to the current file being linted.
         */
        return function CustomRule(reporter, $, ast, info) {
            logger$2.debug("Called", config);
            return config(reporter, $, ast, info);
        };
    }
};

var custom$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': custom
});

const logger$1 = Logger("rule:elm");

/** @typedef {import("../lib/reporter.js")} Reporter */
/** @typedef {import("../lib/parse.js").AST} AST */
/** @typedef {import("../lib/parse.js").Node} Node */

/**
 * @typedef {Object<string,Boolean|Number|Array<Number>>} ElmConfig
 * The key is used as selector. The value has the following meanings:  
 * - `{Boolean}` If true the selector must be matched. If false the selector must not be matched.  
 * - `{Number}` The number of elements the selector must resolve to. Must be exact.  
 * - `{Array<Number>}` The number of elements the selector resolves to must be between the first and the second number.
 * 
 * Note that if an element is disallowed by one rule, but allowed by another, it will be allowed.
 * This allows you to do e.g. `{ "title": false, "svg > title": true }`.
 */
/**
 * @typedef RuleElmResult
 * @property {Node} [elm] The element the result relates to
 * @property {String} message The message the result is described by
 */
/**
 * @typedef RuleExecution
 * @property {RuleElmResult[]} allowed The elements allowed by the rule
 * @property {RuleElmResult[]} disallowed The elements disallowed by the rule
 */

/**
 * Workflow:
 * 1. Find all { allowed: [], disallowed: [] }
 * 2. Filter .disallowed by not in .allowed
 * 3. If .disallowed.length, fail
 * 
 * Rules act like this:
 * - {true} If found, put in allowed
 * - {false} If found, put in disallowed
 * - {Number} If exact match, put all in allowed. If not, put all in disallowed.
 * - {Array<Number>} If match, put all in allowed. If not, put all in disallowed.
 * 
 * This means that e.g. `{ "b": 2, "a > b": true}` with "<b/><b/><a><b/><b/></a>"
 * will fail, which is something to keep in mind.
 */

/**
 * Executes a rule, returning the RuleExecution.
 * @param {String} selector The selector of the rule
 * @param {Boolean|Number|Array<Number>} config The config of the rule
 * @param {Cheerio} $ The cheerio representation of the document
 */
function executeRule(selector, config, $) {
    /** @type {RuleExecution} */
    const outp = {
        allowed: [],
        disallowed: [],
    };
    /** @type {RuleElmResult[]} */
    const matches = $.find(selector).toArray().map(
        elm => ({ elm, message: "" })
    );
    let allowed = null;
    let message = null;
    switch (typeof config) {
        case "boolean":
            if (config) {
                allowed = true;
                if (!matches.length) {
                    outp.disallowed.push({
                        elm: null,
                        message: `Expected '${selector}', none found`,
                    });
                }
            } else {
                allowed = false;
                message = "Element disallowed";
            }
            break;
        case "number":
            if (matches.length === config) {
                allowed = true;
            } else {
                allowed = false;
                message = `Found ${matches.length} elements for '${selector}', expected ${config}`;
                if (!matches.length) {
                    matches.push({ elm: null, message: "" });
                }
            }
            break;
        default:
            if (config instanceof Array && config.length === 2
                    && typeof config[0] === "number" && typeof config[1] === "number") {
                if (matches.length >= config[0] && matches.length <= config[1]) {
                    allowed = true;
                } else {
                    outp.disallowed.push({
                        elm: null,
                        message: `Found ${matches.length} elements for '${selector}', expected between ${config[0]} and ${config[1]}`,
                    });
                }
            } else {
                throw `Unknown config type '${typeof config}' (${JSON.stringify(config)})`;
            }
    }
    if (allowed === true) {
        outp.allowed = outp.allowed.concat(matches);
    } else if (allowed === false) {
        outp.disallowed = outp.disallowed.concat(matches.map(
            match => {
                match.message = message;
                return match;
            }
        ));
    }
    return outp;
}

var elm = {
    /**
     * Generates a linting function from a config
     * @param {ElmConfig} config 
     */
    generate(config) {
        /**
         * Performs the linting according to the previously passed config.
         * @param {Reporter} reporter The reporter to report warnings/errors to
         * @param {Cheerio} $ A cheerio representation of the document
         * @param {AST} ast The underlying AST representation of the document.
         *                  This should be given to Reporter when warning/erroring with a node.
         */
        return function ElmRule(reporter, $, ast) {
            logger$1.debug("Called", config);
            // gather the result of every execution
            const executions = Object.keys(config)
                .map(selector => {
                    try {
                        return executeRule(selector, config[selector], $);
                    } catch (e) {
                        if (e instanceof Error) {
                            reporter.exception(e);
                        } else {
                            reporter.warn(`Rule '${selector}' failed to lint: ${e}`);
                        }
                        return null;
                    }
                }).filter(v => v);
            // then filter out the disallowed elms that are allowed elsewhere
            /** @type {Node[]} */
            const allowedElms = [];
            /** @type {RuleElmResult[]} */
            const disallowed = [];
            // first gather the allowed elms
            executions.forEach(execution => {
                allowedElms.push(...execution.allowed.map(result => result.elm));
            });
            // the filter the disallowed elms by whether they are allowed elsewhere
            executions.forEach(execution => {
                disallowed.push(...execution.disallowed.filter(
                    result => !allowedElms.includes(result.elm)
                ));
            });
            // finally report all the remaining disallowed elms
            disallowed.forEach(result => {
                reporter.error(result.message, result.elm, ast);
            });
        };
    }
};

var elm$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': elm
});

const logger = Logger("rule:valid");

/** @typedef {import("../lib/reporter.js")} Reporter */
/** @typedef {import("../lib/parse.js").AST} AST */
/** @typedef {import("../lib/parse.js").Node} Node */

/**
* Workflow:
* 1. Validate the SVG using fast-xml-parser
* 2. If the SVG is not valid, report an error
*/

var valid = {
    /**
     * Generates a linting function from a config
     * @param {Boolean} config
     */
    generate(enabled) {
        /**
         * Performs the linting according to the previously passed config.
         * @param {Reporter} reporter The reporter to report warnings/errors to
         * @param {Cheerio} $ A cheerio representation of the document
         * @param {AST} ast The underlying AST representation of the document.
         *                  This should be given to Reporter when warning/erroring with a node.
         */
        return function ValidRule(reporter, $, ast) {
            logger.debug("Called", enabled);
            if (!enabled) {
                return;
            }
            if (!ast.source) {
                logger.debug("Encountered empty SVG. Considering valid");
                return;
            }
            const result = fastXmlParser.XMLValidator.validate(ast.source);
            if (result !== true) {
                reporter.error(result.err.msg, null, ast);
            }
        };
    }
};

var valid$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': valid
});

module.exports = svglint;
