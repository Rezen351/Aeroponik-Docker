var ue = Object.defineProperty;
var oe = (i, e, t) => e in i ? ue(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t;
var d = (i, e, t) => (oe(i, typeof e != "symbol" ? e + "" : e, t), t);
import { ref as k, watch as g, defineComponent as re, computed as ne } from "vue";
var E = /* @__PURE__ */ ((i) => (i.Empty = "empty", i.Value = "value", i.Range = "range", i.EveryX = "everyX", i.Combined = "combined", i.NoSpecific = "noSpecific", i))(E || {}), V = /* @__PURE__ */ ((i) => (i.Prefix = "prefix", i.Suffix = "suffix", i.Text = "text", i))(V || {});
class le {
  constructor(e) {
    d(this, "field");
    d(this, "itemMap");
    this.field = e, this.itemMap = this.field.items.reduce(
      (t, r) => (t[r.value] = r, t),
      {}
    );
  }
  get id() {
    return this.field.id;
  }
  get items() {
    return this.field.items;
  }
  get onChange() {
    return this.field.onChange;
  }
  get segmentFactories() {
    return this.field.segmentFactories;
  }
  get min() {
    return this.items[0].value;
  }
  get max() {
    return this.items[this.items.length - 1].value;
  }
  getItem(e) {
    return this.itemMap[e];
  }
}
function fe(i, e, t = 1) {
  const r = [];
  for (let n = i; n <= e; n += t)
    r.push(n);
  return r;
}
class xe {
  constructor(e, t, r = 1) {
    d(this, "start");
    d(this, "end");
    d(this, "step");
    return this.start = e, this.end = t, this.step = r, new Proxy(this, {
      get: function(n, a) {
        const s = typeof a == "string" ? parseInt(a) : a;
        return typeof s == "number" && s >= 0 && s <= n.length ? n.start + n.step * s : Reflect.get(n, a);
      }
    });
  }
  get length() {
    return (this.end - this.start) / this.step + 1;
  }
  [Symbol.iterator]() {
    let e = -1;
    return {
      next: () => ({ value: this[++e], done: this[e + 1] === void 0 })
    };
  }
}
function I(i, e, t = (n) => n + "", r = (n) => n + "") {
  const n = [];
  for (const a of new xe(i, e))
    n.push({
      text: t(a),
      alt: r(a),
      value: a
    });
  return n;
}
function ce(i, e = "crontab") {
  const t = (n, a = !1) => new Date(2021, n - 1, 1).toLocaleDateString(i, {
    month: a ? "short" : "long"
  }), r = (n, a = !1) => new Date(2021, 0, 3 + n).toLocaleDateString(i, {
    weekday: a ? "short" : "long"
  });
  return {
    secondItems: I(0, 59, (n) => Q(n, 2)),
    minuteItems: I(0, 59, (n) => Q(n, 2)),
    hourItems: I(0, 23, (n) => Q(n, 2)),
    dayItems: I(1, 31),
    monthItems: I(1, 12, t, (n) => t(n, !0)),
    dayOfWeekItems: e === "quartz" ? I(
      1,
      7,
      (n) => r(n - 1),
      (n) => r(n - 1, !0)
    ) : I(0, 6, r, (n) => r(n, !0))
  };
}
function Q(i, e) {
  const t = i + "";
  return t.length < e ? new Array(e - t.length).fill("0").join("") + i : t;
}
function z(i) {
  return i && typeof i == "object" && !Array.isArray(i);
}
function Y(i, ...e) {
  if (!z(i) || e.length === 0)
    return;
  const t = e.shift();
  if (z(t))
    for (const [r, n] of Object.entries(t))
      z(n) ? (z(i[r]) || (i[r] = {}), Y(i[r], t[r])) : i[r] = t[r];
  return e.length > 0 && Y(i, ...e), i;
}
function ie(i, ...e) {
  if (e.length === 0)
    return i;
  for (const t of e[0])
    if (t in i) {
      const r = ie(i[t], ...e.slice(1));
      if (r !== void 0)
        return r;
    }
}
function pe(i) {
  for (let e = 1; e < i.length; e++)
    if (i[e - 1] + 1 !== i[e])
      return !1;
  return !0;
}
function de() {
  throw new Error("not implemented");
}
function me(i, e, t = !0) {
  const r = [];
  for (let n = 0; n < i.length; n += e) {
    const a = i.slice(n, n + e);
    for (; t && a.length < e; )
      a.push(null);
    r.push(a);
  }
  return r;
}
class J {
  constructor(e) {
    d(this, "field");
    d(this, "type", E.NoSpecific);
    this.field = e;
  }
  toCron() {
    return "?";
  }
  toArray() {
    return [];
  }
  get items() {
    return {};
  }
  static fromString(e, t) {
    return e !== "?" ? null : new J(t);
  }
}
class X {
  constructor(e) {
    d(this, "field");
    d(this, "type", E.Empty);
    this.field = e;
  }
  toCron() {
    return "*";
  }
  toArray() {
    return [];
  }
  get items() {
    return {};
  }
  static fromString(e, t) {
    return e !== "*" ? null : new X(t);
  }
  static fromArray(e, t) {
    const { items: r } = t;
    if (e.length === 0)
      return new X(t);
    if (e.length !== r.length)
      return null;
    for (const n of r)
      if (!e.includes(n.value))
        return null;
    return pe(r.map((n) => n.value)) ? new X(t) : null;
  }
}
const L = class L {
  constructor(e, t, r) {
    d(this, "field");
    d(this, "type", E.Range);
    d(this, "start");
    d(this, "end");
    this.field = e, this.start = t, this.end = r;
  }
  toCron() {
    return `${this.start}-${this.end}`;
  }
  toArray() {
    const e = this.start, t = this.end;
    return fe(e, t);
  }
  get items() {
    return {
      start: this.field.itemMap[this.start],
      end: this.field.itemMap[this.end]
    };
  }
  static fromString(e, t) {
    if (!L.re.test(e))
      return null;
    const { min: r, max: n } = t, a = e.split("-"), s = parseInt(a[0]), u = parseInt(a[1]);
    return s > u || s < r || u > n ? null : new L(t, s, u);
  }
};
d(L, "re", /^\d+-\d+$/);
let $ = L;
const Z = (i, e, t) => {
  const r = [];
  for (let n = e; n <= t; n += i)
    r.push(n);
  return r;
}, j = class j {
  constructor(e, t, r, n) {
    d(this, "field");
    d(this, "type", E.EveryX);
    d(this, "every");
    d(this, "start");
    d(this, "end");
    this.field = e, this.every = t, this.start = r ?? e.min, this.end = n ?? e.max;
  }
  toCron() {
    return this.start == this.field.min && this.end == this.field.max ? `*/${this.every}` : `${this.start}-${this.end}/${this.every}`;
  }
  toArray() {
    return Z(this.every, this.start, this.end);
  }
  get items() {
    return {
      every: this.field.itemMap[this.every],
      start: this.field.itemMap[this.start],
      end: this.field.itemMap[this.end]
    };
  }
  static fromString(e, t) {
    if (!j.re.test(e))
      return null;
    const [r, n] = e.split("/"), a = parseInt(n);
    if (a > t.items.length)
      return null;
    const s = e.split("-").map((x) => parseInt(x)), u = r == "*" ? t.min : s[0], o = r == "*" ? t.max : s[1];
    return Z(a, u, o).length == 0 ? null : new j(t, a, u, o);
  }
  static fromArray(e, t) {
    const { min: r, max: n } = t;
    if (e.length < 3)
      return null;
    const a = e[1] - e[0];
    if (a <= 1 || e[0] != r)
      return null;
    const s = e[e.length - 1];
    if (n - s >= a)
      return null;
    for (let u = 2; u < e.length; u++)
      if (e[u] - e[u - 1] != a)
        return null;
    return new j(t, a, r, n);
  }
};
d(j, "re", /^(\*|\d+-\d+)\/\d+$/);
let P = j;
class R {
  constructor(e, t) {
    d(this, "field");
    d(this, "type", E.Value);
    d(this, "value");
    this.field = e, this.value = t;
  }
  toCron() {
    return `${this.value}`;
  }
  toArray() {
    return [this.value];
  }
  get items() {
    return {
      value: this.field.itemMap[this.value]
    };
  }
  static fromString(e, t) {
    const { min: r, max: n } = t, a = parseInt(e);
    return String(a) === e && a >= r && a <= n ? new R(t, a) : null;
  }
  static fromArray(e, t) {
    const { min: r, max: n } = t;
    if (e.length != 1)
      return null;
    const a = e[0];
    return a < r || a > n ? null : a;
  }
}
const T = class T {
  constructor(e, t = []) {
    d(this, "field");
    d(this, "segments");
    this.field = e, this.segments = t;
  }
  get type() {
    return this.segments.length == 1 ? this.segments[0].type : E.Range;
  }
  addSegment(e) {
    this.segments.push(e);
  }
  toCron() {
    return this.segments.map((e) => e.toCron()).join(",");
  }
  toArray() {
    const e = /* @__PURE__ */ new Set();
    for (const t of this.segments)
      t.toArray().forEach((r) => e.add(r));
    return Array.from(e);
  }
  get items() {
    return de();
  }
  static fromString(e, t) {
    const r = t.segmentFactories ?? T.segmentFactories;
    let n = [];
    for (const a of e.split(",")) {
      if (a === "*") {
        n = [new X(t)];
        break;
      }
      let s = null;
      for (const u of r)
        if (s = u(a, t), s !== null)
          break;
      if (s === null)
        return null;
      n.push(s);
    }
    return new T(t, n);
  }
  static fromArray(e, t) {
    const { min: r, max: n } = t, a = e[0], s = e[e.length - 1];
    if (a < r || s > n)
      return null;
    const u = [];
    let o = 0;
    for (let x = 0; x < e.length; x++)
      (e[x + 1] === void 0 || e[x + 1] - e[x] > 1) && (x === o ? u.push(new R(t, e[o])) : u.push(new $(t, e[o], e[x])), o = x + 1);
    return new T(t, u);
  }
};
d(T, "segmentFactories", [
  X.fromString,
  P.fromString,
  $.fromString,
  R.fromString
]);
let D = T;
function _(i, e) {
  return D.fromString(i, e);
}
function ve(i, e) {
  for (const t of [
    X.fromArray,
    P.fromArray,
    D.fromArray
  ]) {
    const r = t(i, e);
    if (r != null)
      return r;
  }
  return null;
}
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */
var ye = Object.prototype.toString, F = Array.isArray || function(e) {
  return ye.call(e) === "[object Array]";
};
function G(i) {
  return typeof i == "function";
}
function he(i) {
  return F(i) ? "array" : typeof i;
}
function K(i) {
  return i.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function ee(i, e) {
  return i != null && typeof i == "object" && e in i;
}
function ge(i, e) {
  return i != null && typeof i != "object" && i.hasOwnProperty && i.hasOwnProperty(e);
}
var Se = RegExp.prototype.test;
function we(i, e) {
  return Se.call(i, e);
}
var ke = /\S/;
function Ce(i) {
  return !we(ke, i);
}
var Oe = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
function be(i) {
  return String(i).replace(/[&<>"'`=\/]/g, function(t) {
    return Oe[t];
  });
}
var qe = /\s*/, We = /\s+/, te = /\s*=/, Ae = /\s*\}/, Xe = /#|\^|\/|>|\{|&|=|!/;
function Me(i, e) {
  if (!i)
    return [];
  var t = !1, r = [], n = [], a = [], s = !1, u = !1, o = "", x = 0;
  function m() {
    if (s && !u)
      for (; a.length; )
        delete n[a.pop()];
    else
      a = [];
    s = !1, u = !1;
  }
  var c, h, A;
  function W(b) {
    if (typeof b == "string" && (b = b.split(We, 2)), !F(b) || b.length !== 2)
      throw new Error("Invalid tags: " + b);
    c = new RegExp(K(b[0]) + "\\s*"), h = new RegExp("\\s*" + K(b[1])), A = new RegExp("\\s*" + K("}" + b[1]));
  }
  W(e || q.tags);
  for (var l = new N(i), v, f, y, O, M, p; !l.eos(); ) {
    if (v = l.pos, y = l.scanUntil(c), y)
      for (var S = 0, w = y.length; S < w; ++S)
        O = y.charAt(S), Ce(O) ? (a.push(n.length), o += O) : (u = !0, t = !0, o += " "), n.push(["text", O, v, v + 1]), v += 1, O === `
` && (m(), o = "", x = 0, t = !1);
    if (!l.scan(c))
      break;
    if (s = !0, f = l.scan(Xe) || "name", l.scan(qe), f === "=" ? (y = l.scanUntil(te), l.scan(te), l.scanUntil(h)) : f === "{" ? (y = l.scanUntil(A), l.scan(Ae), l.scanUntil(h), f = "&") : y = l.scanUntil(h), !l.scan(h))
      throw new Error("Unclosed tag at " + l.pos);
    if (f == ">" ? M = [f, y, v, l.pos, o, x, t] : M = [f, y, v, l.pos], x++, n.push(M), f === "#" || f === "^")
      r.push(M);
    else if (f === "/") {
      if (p = r.pop(), !p)
        throw new Error('Unopened section "' + y + '" at ' + v);
      if (p[1] !== y)
        throw new Error('Unclosed section "' + p[1] + '" at ' + v);
    } else
      f === "name" || f === "{" || f === "&" ? u = !0 : f === "=" && W(y);
  }
  if (m(), p = r.pop(), p)
    throw new Error('Unclosed section "' + p[1] + '" at ' + l.pos);
  return Ve(Ie(n));
}
function Ie(i) {
  for (var e = [], t, r, n = 0, a = i.length; n < a; ++n)
    t = i[n], t && (t[0] === "text" && r && r[0] === "text" ? (r[1] += t[1], r[3] = t[3]) : (e.push(t), r = t));
  return e;
}
function Ve(i) {
  for (var e = [], t = e, r = [], n, a, s = 0, u = i.length; s < u; ++s)
    switch (n = i[s], n[0]) {
      case "#":
      case "^":
        t.push(n), r.push(n), t = n[4] = [];
        break;
      case "/":
        a = r.pop(), a[5] = n[2], t = r.length > 0 ? r[r.length - 1][4] : e;
        break;
      default:
        t.push(n);
    }
  return e;
}
function N(i) {
  this.string = i, this.tail = i, this.pos = 0;
}
N.prototype.eos = function() {
  return this.tail === "";
};
N.prototype.scan = function(e) {
  var t = this.tail.match(e);
  if (!t || t.index !== 0)
    return "";
  var r = t[0];
  return this.tail = this.tail.substring(r.length), this.pos += r.length, r;
};
N.prototype.scanUntil = function(e) {
  var t = this.tail.search(e), r;
  switch (t) {
    case -1:
      r = this.tail, this.tail = "";
      break;
    case 0:
      r = "";
      break;
    default:
      r = this.tail.substring(0, t), this.tail = this.tail.substring(t);
  }
  return this.pos += r.length, r;
};
function U(i, e) {
  this.view = i, this.cache = { ".": this.view }, this.parent = e;
}
U.prototype.push = function(e) {
  return new U(e, this);
};
U.prototype.lookup = function(e) {
  var t = this.cache, r;
  if (t.hasOwnProperty(e))
    r = t[e];
  else {
    for (var n = this, a, s, u, o = !1; n; ) {
      if (e.indexOf(".") > 0)
        for (a = n.view, s = e.split("."), u = 0; a != null && u < s.length; )
          u === s.length - 1 && (o = ee(a, s[u]) || ge(a, s[u])), a = a[s[u++]];
      else
        a = n.view[e], o = ee(n.view, e);
      if (o) {
        r = a;
        break;
      }
      n = n.parent;
    }
    t[e] = r;
  }
  return G(r) && (r = r.call(this.view)), r;
};
function C() {
  this.templateCache = {
    _cache: {},
    set: function(e, t) {
      this._cache[e] = t;
    },
    get: function(e) {
      return this._cache[e];
    },
    clear: function() {
      this._cache = {};
    }
  };
}
C.prototype.clearCache = function() {
  typeof this.templateCache < "u" && this.templateCache.clear();
};
C.prototype.parse = function(e, t) {
  var r = this.templateCache, n = e + ":" + (t || q.tags).join(":"), a = typeof r < "u", s = a ? r.get(n) : void 0;
  return s == null && (s = Me(e, t), a && r.set(n, s)), s;
};
C.prototype.render = function(e, t, r, n) {
  var a = this.getConfigTags(n), s = this.parse(e, a), u = t instanceof U ? t : new U(t, void 0);
  return this.renderTokens(s, u, r, e, n);
};
C.prototype.renderTokens = function(e, t, r, n, a) {
  for (var s = "", u, o, x, m = 0, c = e.length; m < c; ++m)
    x = void 0, u = e[m], o = u[0], o === "#" ? x = this.renderSection(u, t, r, n, a) : o === "^" ? x = this.renderInverted(u, t, r, n, a) : o === ">" ? x = this.renderPartial(u, t, r, a) : o === "&" ? x = this.unescapedValue(u, t) : o === "name" ? x = this.escapedValue(u, t, a) : o === "text" && (x = this.rawValue(u)), x !== void 0 && (s += x);
  return s;
};
C.prototype.renderSection = function(e, t, r, n, a) {
  var s = this, u = "", o = t.lookup(e[1]);
  function x(h) {
    return s.render(h, t, r, a);
  }
  if (o) {
    if (F(o))
      for (var m = 0, c = o.length; m < c; ++m)
        u += this.renderTokens(e[4], t.push(o[m]), r, n, a);
    else if (typeof o == "object" || typeof o == "string" || typeof o == "number")
      u += this.renderTokens(e[4], t.push(o), r, n, a);
    else if (G(o)) {
      if (typeof n != "string")
        throw new Error("Cannot use higher-order sections without the original template");
      o = o.call(t.view, n.slice(e[3], e[5]), x), o != null && (u += o);
    } else
      u += this.renderTokens(e[4], t, r, n, a);
    return u;
  }
};
C.prototype.renderInverted = function(e, t, r, n, a) {
  var s = t.lookup(e[1]);
  if (!s || F(s) && s.length === 0)
    return this.renderTokens(e[4], t, r, n, a);
};
C.prototype.indentPartial = function(e, t, r) {
  for (var n = t.replace(/[^ \t]/g, ""), a = e.split(`
`), s = 0; s < a.length; s++)
    a[s].length && (s > 0 || !r) && (a[s] = n + a[s]);
  return a.join(`
`);
};
C.prototype.renderPartial = function(e, t, r, n) {
  if (r) {
    var a = this.getConfigTags(n), s = G(r) ? r(e[1]) : r[e[1]];
    if (s != null) {
      var u = e[6], o = e[5], x = e[4], m = s;
      o == 0 && x && (m = this.indentPartial(s, x, u));
      var c = this.parse(m, a);
      return this.renderTokens(c, t, r, m, n);
    }
  }
};
C.prototype.unescapedValue = function(e, t) {
  var r = t.lookup(e[1]);
  if (r != null)
    return r;
};
C.prototype.escapedValue = function(e, t, r) {
  var n = this.getConfigEscape(r) || q.escape, a = t.lookup(e[1]);
  if (a != null)
    return typeof a == "number" && n === q.escape ? String(a) : n(a);
};
C.prototype.rawValue = function(e) {
  return e[1];
};
C.prototype.getConfigTags = function(e) {
  return F(e) ? e : e && typeof e == "object" ? e.tags : void 0;
};
C.prototype.getConfigEscape = function(e) {
  if (e && typeof e == "object" && !F(e))
    return e.escape;
};
var q = {
  name: "mustache.js",
  version: "4.2.0",
  tags: ["{{", "}}"],
  clearCache: void 0,
  escape: void 0,
  parse: void 0,
  render: void 0,
  Scanner: void 0,
  Context: void 0,
  Writer: void 0,
  /**
   * Allows a user to override the default caching strategy, by providing an
   * object with set, get and clear methods. This can also be used to disable
   * the cache by setting it to the literal `undefined`.
   */
  set templateCache(i) {
    H.templateCache = i;
  },
  /**
   * Gets the default or overridden caching object from the default writer.
   */
  get templateCache() {
    return H.templateCache;
  }
}, H = new C();
q.clearCache = function() {
  return H.clearCache();
};
q.parse = function(e, t) {
  return H.parse(e, t);
};
q.render = function(e, t, r, n) {
  if (typeof e != "string")
    throw new TypeError('Invalid template! Template should be a "string" but "' + he(e) + '" was given as the first argument for mustache#render(template, view, partials)');
  return H.render(e, t, r, n);
};
q.escape = be;
q.Scanner = N;
q.Context = U;
q.Writer = C;
const Ee = {
  "*": {
    prefix: "每",
    suffix: "",
    text: "未知",
    "*": {
      empty: { text: "每 {{field.id}}" },
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "每 {{every.value}}" }
    },
    month: {
      "*": { prefix: "的" },
      empty: { text: "每月" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "的" },
      empty: { text: "每日" },
      value: { text: "{{value.alt}}号" },
      range: { text: "{{start.alt}}号-{{end.alt}}号" },
      noSpecific: {
        text: "无特定日期"
      }
    },
    dayOfWeek: {
      "*": { prefix: "的" },
      empty: { text: "一周的每一天" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" },
      noSpecific: {
        text: "无特定星期几"
      }
    },
    hour: {
      "*": { prefix: "的" },
      empty: { text: "每小时" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "每分钟" }
    },
    second: {
      "*": { prefix: ":" },
      empty: { text: "每秒" }
    }
  },
  minute: {
    text: "分"
  },
  hour: {
    text: "小时",
    minute: {
      "*": {
        prefix: ":",
        suffix: "分钟"
      },
      empty: { text: "每" }
    }
  },
  day: {
    text: "天"
  },
  week: {
    text: "周",
    dayOfWeek: {
      "*": { prefix: "的" },
      empty: { text: "每天" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    }
  },
  month: {
    text: "月",
    dayOfWeek: {
      "*": { prefix: "和" }
    },
    day: {
      "*": { prefix: "的" }
    }
  },
  year: {
    text: "年",
    dayOfWeek: {
      "*": { prefix: "和" }
    }
  },
  //quartz format
  "q-second": {
    text: "秒"
  },
  "q-minute": {
    text: "分钟",
    second: {
      "*": {
        prefix: ":",
        suffix: "秒"
      },
      empty: { text: "每" }
    }
  },
  "q-hour": {
    text: "小时",
    minute: {
      "*": {
        prefix: ":"
      }
    }
  }
}, je = {
  "*": {
    prefix: "Hver",
    suffix: "",
    text: "Ukendt",
    "*": {
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "hver {{every.value}}" }
    },
    month: {
      "*": { prefix: "i" },
      empty: { text: "hver måned" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "og" },
      empty: { text: "hver dag i måneden" },
      value: { text: "{{value.alt}}." },
      range: { text: "{{start.alt}}.-{{end.alt}}." },
      noSpecific: {
        text: "ingen specifik dag"
      }
    },
    dayOfWeek: {
      "*": { prefix: "på" },
      empty: { text: "hver dag i ugen" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" },
      noSpecific: {
        text: "ingen specifik dag i ugen"
      }
    },
    hour: {
      "*": { prefix: "klokken" },
      empty: { text: "hver time" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "hvert minut" }
    },
    second: {
      "*": { prefix: ":" },
      empty: { text: "hvert sekund" }
    }
  },
  second: {
    prefix: "Hvert"
  },
  minute: {
    prefix: "Hvert",
    text: "Minut"
  },
  hour: {
    text: "Time",
    minute: {
      "*": {
        prefix: "ved",
        suffix: "minutter"
      },
      empty: { text: "alle" }
    }
  },
  day: {
    text: "Dag"
  },
  week: {
    text: "Uge"
  },
  month: {
    text: "Måned",
    dayOfWeek: {
      "*": { prefix: "og" }
    }
  },
  year: {
    prefix: "Hvert",
    text: "År",
    dayOfWeek: {
      "*": { prefix: "og" }
    }
  },
  // quartz format
  "q-second": {
    text: "Sekund"
  },
  "q-minute": {
    text: "Minut",
    second: {
      "*": {
        suffix: "sekund(er)"
      },
      empty: { text: "hvert" }
    }
  },
  "q-hour": {
    text: "Time",
    minute: {
      "*": {
        prefix: "på"
      }
    }
  }
}, Te = {
  "*": {
    prefix: "Jede",
    suffix: "",
    text: "Unknown",
    "*": {
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "alle {{every.value}}" }
    },
    month: {
      "*": { prefix: "im" },
      empty: {
        prefix: "in",
        text: "jedem Monat"
      },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "den" },
      empty: {
        prefix: "an",
        text: "jedem Tag"
      },
      everyX: {
        prefix: "",
        text: "alle {{every.value}} Tage"
      },
      noSpecific: {
        prefix: "an",
        text: "keinem bestimmten Tag"
      }
    },
    dayOfWeek: {
      "*": { prefix: "am" },
      empty: {
        prefix: "an",
        text: "jedem Wochentag"
      },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" },
      noSpecific: {
        prefix: "und",
        text: "keinem bestimmten Wochentag"
      }
    },
    hour: {
      "*": { prefix: "um" },
      empty: {
        prefix: "zu",
        text: "jeder Stunde"
      },
      everyX: {
        prefix: "",
        text: "alle {{every.value}} Stunden"
      }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "jede Minute" },
      everyX: {
        prefix: "",
        text: "alle {{every.value}} Minuten"
      }
    },
    second: {
      "*": { prefix: ":" },
      empty: { text: "jede Sekunde" },
      everyX: {
        prefix: "",
        text: "alle {{every.value}} Sekunden"
      }
    }
  },
  minute: {
    text: "Minute"
  },
  hour: {
    text: "Stunde",
    minute: {
      "*": {
        prefix: "zu",
        suffix: "Minute(n)"
      },
      empty: { text: "jeder" }
    }
  },
  day: {
    prefix: "Jeden",
    text: "Tag"
  },
  week: {
    text: "Woche"
  },
  month: {
    prefix: "Jedes",
    text: "Monat"
  },
  year: {
    prefix: "Jedes",
    text: "Jahr"
  },
  //quartz format
  "q-second": {
    text: "Sekunde"
  },
  "q-minute": {
    text: "Minute",
    second: {
      "*": {
        prefix: "und"
      }
    }
  },
  "q-hour": {
    text: "Stunde",
    minute: {
      "*": {
        prefix: "und"
      }
    },
    second: {
      "*": {
        prefix: "und"
      }
    }
  }
}, $e = {
  "*": {
    prefix: "Every",
    suffix: "",
    text: "Unknown",
    "*": {
      empty: { text: "every {{field.id}}" },
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "every {{every.value}}" }
    },
    month: {
      "*": { prefix: "in" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "on" },
      noSpecific: {
        text: "no specific day"
      }
    },
    dayOfWeek: {
      "*": { prefix: "on" },
      empty: { text: "every day of the week" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" },
      noSpecific: {
        text: "no specific day of the week"
      }
    },
    hour: {
      "*": { prefix: "at" }
    },
    minute: {
      "*": { prefix: ":" }
    },
    second: {
      "*": { prefix: ":" }
    }
  },
  minute: {
    text: "Minute"
  },
  hour: {
    text: "Hour",
    minute: {
      "*": {
        prefix: "at",
        suffix: "minute(s)"
      },
      empty: { text: "every" }
    }
  },
  day: {
    text: "Day"
  },
  week: {
    text: "Week"
  },
  month: {
    text: "Month",
    dayOfWeek: {
      "*": { prefix: "and" }
    }
  },
  year: {
    text: "Year",
    dayOfWeek: {
      "*": { prefix: "and" }
    }
  },
  //quartz format
  "q-second": {
    text: "Second"
  },
  "q-minute": {
    text: "Minute",
    second: {
      "*": {
        prefix: "at",
        suffix: "second(s)"
      },
      empty: { text: "every" }
    }
  },
  "q-hour": {
    text: "Hour",
    minute: {
      "*": {
        prefix: "at"
      }
    }
  }
}, Pe = {
  "*": {
    prefix: "todos los",
    suffix: "",
    text: "Desconocido",
    "*": {
      empty: { text: "todos los {{ field.id }}" },
      value: { text: "{{ value.text }}" },
      range: { text: "{{ start.text }}-{{ end.text }}" },
      everyX: { text: "todos/as {{ every.value }}" }
    },
    month: {
      "*": { prefix: "en" },
      empty: { text: "todos los meses" },
      value: { text: "{{ value.alt }}" },
      range: { text: "{{ start.alt }}-{{ end.alt }}" }
    },
    day: {
      "*": { prefix: "en" },
      empty: { text: "todos los días" },
      value: { text: "los días {{ value.alt }}" }
    },
    dayOfWeek: {
      "*": { prefix: "de" },
      empty: { text: "todos los días de la semana" },
      value: { text: "los {{ value.alt }}" },
      range: { text: "{{ start.alt }}-{{ end.alt }}" }
    },
    hour: {
      "*": { prefix: "a" },
      empty: { text: "todas las horas" },
      value: { text: "las {{ value.text }}" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "todos los minutos" }
    }
  },
  minute: {
    prefix: "todos los",
    text: "minutos"
  },
  hour: {
    prefix: "todas las",
    text: "horas",
    minute: {
      "*": {
        prefix: "a los",
        suffix: "minutos"
      },
      empty: { text: "todos", prefix: "a", suffix: "los minutos" }
    }
  },
  day: {
    text: "Días"
  },
  week: {
    text: "Semanas"
  },
  month: {
    text: "Meses",
    dayOfWeek: {
      "*": { prefix: "y" }
    }
  },
  year: {
    text: "años",
    dayOfWeek: {
      "*": { prefix: "y" }
    }
  }
}, Re = {
  "*": {
    prefix: "Toutes",
    suffix: "",
    text: "Inconnu",
    "*": {
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "tous les {{every.value}}" }
    },
    month: {
      "*": { prefix: "en" },
      empty: { prefix: "en", text: "tous les mois" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "le" },
      empty: { prefix: "à", text: "tous les jours" },
      everyX: { prefix: "", text: "tous les {{every.value}} jours" },
      noSpecific: { prefix: "à", text: "aucun jour particulier" }
    },
    dayOfWeek: {
      "*": { prefix: "le" },
      empty: { prefix: "à", text: "tous les jours de la semaine" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" },
      noSpecific: { prefix: "et", text: "aucun jour de la semaine particulier" }
    },
    hour: {
      "*": { prefix: "à" },
      empty: { prefix: "à", text: "toutes les heures" },
      everyX: { prefix: "", text: "toutes les {{every.value}} heures" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "toutes les minutes" },
      everyX: { prefix: "", text: "toutes les {{every.value}} minutes" }
    },
    second: {
      "*": { prefix: ":" },
      empty: { text: "toutes les secondes" },
      everyX: { prefix: "", text: "toutes les {{every.value}} secondes" }
    }
  },
  minute: { text: "Minute" },
  hour: {
    text: "Heure",
    minute: { "*": { prefix: "à", suffix: "minute(s)" }, empty: { text: "toutes" } }
  },
  day: { prefix: "Tous", text: "Jour" },
  week: { text: "Semaine" },
  month: { prefix: "Tous", text: "Mois" },
  year: { prefix: "Tous", text: "Année" },
  //quartz format
  "q-second": { text: "Seconde" },
  "q-minute": { text: "Minute", second: { "*": { prefix: "et" } } },
  "q-hour": { text: "Heure", minute: { "*": { prefix: "et" } }, second: { "*": { prefix: "et" } } }
}, Ue = {
  "*": {
    prefix: "בכל",
    suffix: "",
    text: "לא ידוע",
    "*": {
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "כל {{every.value}}" }
    },
    month: {
      "*": { prefix: "ב" },
      empty: { text: "כל חודש" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "ב" },
      empty: { text: "כל יום" },
      value: { text: "יום {{value.alt}} לחודש" },
      noSpecific: {
        text: "ללא יום מוגדר"
      }
    },
    dayOfWeek: {
      "*": { prefix: "ב" },
      empty: { text: "כל יום מימות השבוע" },
      value: { text: "ימי {{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" },
      noSpecific: {
        text: "ללא יום בשבוע מוגדר"
      }
    },
    hour: {
      "*": { prefix: "ב" },
      empty: { text: "כל שעה" },
      value: { text: "שעה {{value.text}}" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "כל דקה" }
    },
    second: {
      "*": { prefix: ":" },
      empty: { text: "כל שניה" }
    }
  },
  minute: {
    text: "דקה"
  },
  hour: {
    text: "שעה",
    minute: {
      "*": {
        prefix: "ב",
        suffix: "דקות"
      },
      empty: { text: "כל" }
    }
  },
  day: {
    text: "יום"
  },
  week: {
    text: "שבוע"
  },
  month: {
    text: "חודש",
    dayOfWeek: {
      "*": { prefix: "ו" }
    }
  },
  year: {
    text: "שנה",
    dayOfWeek: {
      "*": { prefix: "ו" }
    }
  },
  //quartz format
  "q-second": {
    text: "שניה"
  },
  "q-minute": {
    text: "דקה",
    second: {
      "*": {
        prefix: "ב",
        suffix: "שניות"
      },
      empty: { text: "כל" }
    }
  },
  "q-hour": {
    text: "שעה",
    minute: {
      "*": {
        prefix: "ב"
      }
    }
  }
}, Fe = {
  "*": {
    prefix: "हर",
    suffix: "",
    text: "अज्ञात",
    "*": {
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "{{every.value}} हर" }
    },
    month: {
      "*": { prefix: "में" },
      empty: { prefix: "के", text: "हर महीने" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "के" },
      empty: { prefix: "पर", text: "हर दिन" },
      everyX: { prefix: "", text: "{{every.value}} दिन हर" },
      noSpecific: { prefix: "पर", text: "कोई विशेष दिन नहीं" }
    },
    dayOfWeek: {
      "*": { prefix: "पर" },
      empty: { prefix: "पर", text: "हर सप्ताह" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" },
      noSpecific: { prefix: "और", text: "कोई विशेष सप्ताह नहीं" }
    },
    hour: {
      "*": { prefix: "को" },
      empty: { prefix: "पर", text: "हर घंटे" },
      everyX: { prefix: "", text: "{{every.value}} घंटे हर" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "हर मिनट" },
      everyX: { prefix: "", text: "{{every.value}} मिनट हर" }
    },
    second: {
      "*": { prefix: ":" },
      empty: { text: "हर सेकंड" },
      everyX: { prefix: "", text: "{{every.value}} सेकंड हर" }
    }
  },
  minute: { text: "मिनट" },
  hour: { text: "घंटा", minute: { "*": { prefix: "पर", suffix: "मिनट" }, empty: { text: "हर" } } },
  day: { prefix: "हर", text: "दिन" },
  week: { text: "सप्ताह" },
  month: { prefix: "हर", text: "महीना" },
  year: { prefix: "हर", text: "साल" },
  //quartz format
  "q-second": { text: "सेकंड" },
  "q-minute": { text: "मिनट", second: { "*": { prefix: "और" } } },
  "q-hour": { text: "घंटा", minute: { "*": { prefix: "और" } }, second: { "*": { prefix: "और" } } }
}, Le = {
  "*": {
    prefix: "毎",
    suffix: "",
    text: "不明",
    "*": {
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "{{every.value}}ごとに" }
    },
    month: {
      "*": { prefix: "に" },
      empty: { prefix: "の", text: "毎月" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "の" },
      empty: { prefix: "に", text: "毎日" },
      everyX: { prefix: "", text: "{{every.value}}日ごとに" },
      noSpecific: { prefix: "に", text: "特定の日はなし" }
    },
    dayOfWeek: {
      "*": { prefix: "の" },
      empty: { prefix: "に", text: "毎週" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" },
      noSpecific: { prefix: "と", text: "特定の曜日はなし" }
    },
    hour: {
      "*": { prefix: "の" },
      empty: { prefix: "に", text: "毎時" },
      everyX: { prefix: "", text: "{{every.value}}時間ごとに" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "毎分" },
      everyX: { prefix: "", text: "{{every.value}}分ごとに" }
    },
    second: {
      "*": { prefix: ":" },
      empty: { text: "毎秒" },
      everyX: { prefix: "", text: "{{every.value}}秒ごとに" }
    }
  },
  minute: { text: "分" },
  hour: { text: "時", minute: { "*": { prefix: "に", suffix: "分" }, empty: { text: "毎" } } },
  day: { prefix: "毎", text: "日" },
  week: { text: "週" },
  month: { prefix: "毎", text: "月" },
  year: { prefix: "毎", text: "年" },
  //quartz format
  "q-second": { text: "秒" },
  "q-minute": { text: "分", second: { "*": { prefix: "と" } } },
  "q-hour": { text: "時", minute: { "*": { prefix: "と" } }, second: { "*": { prefix: "と" } } }
}, De = {
  "*": {
    prefix: "매",
    suffix: "",
    text: "알 수 없음",
    "*": {
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "{{every.value}}마다" }
    },
    month: {
      "*": { prefix: "에" },
      empty: { prefix: "의", text: "매월" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "의" },
      empty: { prefix: "에", text: "매일" },
      everyX: { prefix: "", text: "{{every.value}}일마다" },
      noSpecific: { prefix: "에", text: "특정한 날 없음" }
    },
    dayOfWeek: {
      "*": { prefix: "의" },
      empty: { prefix: "에", text: "매주" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" },
      noSpecific: { prefix: "과", text: "특정한 요일 없음" }
    },
    hour: {
      "*": { prefix: "의" },
      empty: { prefix: "에", text: "매시" },
      everyX: { prefix: "", text: "{{every.value}}시간마다" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "매분" },
      everyX: { prefix: "", text: "{{every.value}}분마다" }
    },
    second: {
      "*": { prefix: ":" },
      empty: { text: "매초" },
      everyX: { prefix: "", text: "{{every.value}}초마다" }
    }
  },
  minute: { text: "분" },
  hour: { text: "시", minute: { "*": { prefix: "에", suffix: "분" }, empty: { text: "매" } } },
  day: { prefix: "매", text: "일" },
  week: { text: "주" },
  month: { prefix: "매", text: "월" },
  year: { prefix: "매", text: "년" },
  //quartz format
  "q-second": { text: "초" },
  "q-minute": { text: "분", second: { "*": { prefix: "와" } } },
  "q-hour": { text: "시", minute: { "*": { prefix: "와" } }, second: { "*": { prefix: "와" } } }
}, He = {
  "*": {
    prefix: "Todo(a)",
    suffix: "",
    text: "Desconhecido",
    "*": {
      empty: { text: "todo {{field.id}}" },
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "todo {{every.value}}" }
    },
    month: {
      "*": { prefix: "de" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" },
      empty: { text: "todo mês" }
    },
    day: {
      "*": { prefix: "no(s) dia(s)" },
      empty: { text: "todos" }
    },
    dayOfWeek: {
      "*": { prefix: "de" },
      empty: { text: "todos dias da semana" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    hour: {
      "*": { prefix: "às" },
      empty: { text: "cada hora" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "cada minuto" }
    }
  },
  minute: {
    text: "Minuto"
  },
  hour: {
    text: "Hora",
    minute: {
      "*": {
        prefix: "e",
        suffix: "minuto(s)"
      },
      empty: { text: "cada" }
    }
  },
  day: {
    text: "Dia"
  },
  week: {
    text: "Semana"
  },
  month: {
    text: "Mês",
    dayOfWeek: {
      "*": { prefix: "e de" }
    }
  },
  year: {
    text: "Ano",
    dayOfWeek: {
      "*": { prefix: "e de" }
    }
  }
}, Ne = {
  "*": {
    prefix: "Каждый",
    suffix: "",
    text: "Неизвестно",
    "*": {
      value: { text: "{{value.text}}" },
      range: { text: "{{start.text}}-{{end.text}}" },
      everyX: { text: "каждый {{every.value}}" }
    },
    month: {
      "*": { prefix: "в" },
      empty: { prefix: "в", text: "каждом месяце" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" }
    },
    day: {
      "*": { prefix: "в" },
      empty: { prefix: "в", text: "каждый день" },
      everyX: { prefix: "", text: "каждые {{every.value}} дня" },
      noSpecific: { prefix: "в", text: "нет определенного дня" }
    },
    dayOfWeek: {
      "*": { prefix: "по" },
      empty: { prefix: "по", text: "каждому дню недели" },
      value: { text: "{{value.alt}}" },
      range: { text: "{{start.alt}}-{{end.alt}}" },
      noSpecific: { prefix: "и", text: "нет определенного дня недели" }
    },
    hour: {
      "*": { prefix: "в" },
      empty: { prefix: "в", text: "каждый час" },
      everyX: { prefix: "", text: "каждые {{every.value}} часа" }
    },
    minute: {
      "*": { prefix: ":" },
      empty: { text: "каждую минуту" },
      everyX: { prefix: "", text: "каждые {{every.value}} минуты" }
    },
    second: {
      "*": { prefix: ":" },
      empty: { text: "каждую секунду" },
      everyX: { prefix: "", text: "каждые {{every.value}} секунды" }
    }
  },
  minute: { text: "Минута" },
  hour: {
    text: "Час",
    minute: { "*": { prefix: "в", suffix: "минут(а/ы)" }, empty: { text: "каждый" } }
  },
  day: { prefix: "Каждый", text: "День" },
  week: { text: "Неделя" },
  month: { prefix: "Каждый", text: "Месяц" },
  year: { prefix: "Каждый", text: "Год" },
  //quartz format
  "q-second": { text: "Секунда" },
  "q-minute": { text: "Минута", second: { "*": { prefix: "и" } } },
  "q-hour": { text: "Час", minute: { "*": { prefix: "и" } }, second: { "*": { prefix: "и" } } }
}, B = {
  empty: {},
  en: $e,
  de: Te,
  pt: He,
  es: Pe,
  da: je,
  zh: Ee,
  he: Ue,
  ru: Ne,
  fr: Re,
  hi: Fe,
  ja: Le,
  ko: De
};
class ze {
  constructor(e) {
    d(this, "dict");
    this.dict = e;
  }
  getLocaleStr(...e) {
    const t = e.map((r) => [r, "*"]);
    return ie(this.dict, ...t) || "";
  }
  render(e, t, r, n, a) {
    const s = this.getLocaleStr(e, t, r, n);
    return q.render(s, a || {});
  }
}
function Be(i, e) {
  const [t] = i.split("-"), r = B[i.toLowerCase()] || B[t.toLowerCase()] || B.en, n = Y({}, B.en, r, e || {});
  return new ze(n);
}
function Je(i) {
  const { period: e, field: t, initialCron: r = "*", locale: n } = i, a = k(r), s = k(""), u = k([]), o = k(""), x = k(""), m = k(""), c = (l) => {
    const v = l instanceof D ? l.segments : [l];
    o.value = v.map((f) => n.render(e.value.id, t.id, f.type, V.Text, {
      field: t,
      ...f.items
    })).join(","), x.value = n.getLocaleStr(e.value.id, t.id, l.type, V.Prefix), m.value = n.getLocaleStr(e.value.id, t.id, l.type, V.Suffix);
  }, h = (l) => {
    const v = _(l, t);
    v != null ? (u.value = v.toArray(), c(v)) : s.value = `${l} is not a valid cron segment (${t.id})`;
  }, A = (l) => {
    if (a.value == "?" && l.length == 0)
      return;
    const v = ve(l, t);
    v != null ? (a.value = v.toCron(), c(v)) : s.value = `failed to convert ${l} to cron (${t.id})`;
  };
  h(r);
  const W = (l) => {
    const v = Array.from(l).sort((f, y) => f > y ? 1 : -1);
    u.value = v;
  };
  return g(a, (l) => {
    h(l);
  }), g(u, (l) => {
    A(l);
  }), g(e, () => {
    const l = _(a.value, t);
    l != null && c(l);
  }), {
    id: t.id,
    items: t.items,
    cron: a,
    selected: u,
    error: s,
    select: W,
    text: o,
    prefix: x,
    suffix: m
  };
}
function ae(i, e = "*") {
  return new Array(i).fill(e).join(" ");
}
function Qe(i) {
  return i !== void 0;
}
class Ke {
  constructor() {
    d(this, "locale", "en");
    d(this, "format", "crontab");
  }
  initialValue(e, t = "*") {
    return ae(e, t);
  }
  fields(e, t) {
    const r = e == "quartz" || e == "spring", n = ce(t, e), a = (s) => (u, { segmentMap: o }) => {
      if (u.cron.value == "?")
        return;
      const x = o.get(s);
      x && (x.cron.value = "?");
    };
    return [
      ...r ? [{ id: "second", items: n.secondItems }] : [],
      { id: "minute", items: n.minuteItems },
      { id: "hour", items: n.hourItems },
      {
        id: "day",
        items: n.dayItems,
        onChange: r ? a("dayOfWeek") : void 0,
        segmentFactories: r ? [
          X.fromString,
          J.fromString,
          P.fromString,
          $.fromString,
          R.fromString
        ] : void 0
      },
      { id: "month", items: n.monthItems },
      {
        id: "dayOfWeek",
        items: n.dayOfWeekItems,
        onChange: r ? a("day") : void 0,
        segmentFactories: r ? [
          X.fromString,
          J.fromString,
          P.fromString,
          $.fromString,
          R.fromString
        ] : void 0
      }
    ];
  }
  periods(e) {
    const t = e == "quartz" || e == "spring", r = t ? [{ id: "q-second", value: [] }] : [], n = t ? ["second"] : [], a = t ? "q-" : "";
    return [
      ...r,
      { id: a + "minute", value: [...n] },
      { id: a + "hour", value: ["minute", ...n] },
      { id: "day", value: ["hour", "minute", ...n] },
      { id: "week", value: ["dayOfWeek", "hour", "minute", ...n] },
      { id: "month", value: ["day", "dayOfWeek", "hour", "minute", ...n] },
      { id: "year", value: ["month", "day", "dayOfWeek", "hour", "minute", ...n] }
    ];
  }
}
function Ye(i, e, t) {
  const r = e.split(" ");
  if (r.length !== t.length)
    return;
  const n = t.filter((a, s) => !["*", "?"].includes(r[s])).map((a) => a.id);
  return i.find((a) => {
    const s = new Set(a.value);
    return n.every((u) => s.has(u));
  });
}
function Ge(i) {
  const e = new Ke(), t = i.locale ?? e.locale, r = i.format ?? e.format, { customLocale: n, fields: a = e.fields(r, t) } = i, s = i.initialValue ?? e.initialValue(a.length), u = Be(t, n), o = (i.periods ?? e.periods(r)).map((p) => ({
    ...p,
    text: p.text ?? u.getLocaleStr(p.id, V.Text)
  })), x = (i.initialPeriod ? o.find((p) => p.id == i.initialPeriod) : void 0) ?? Ye([...o].reverse(), s, a) ?? o[o.length - 1], m = k(s), c = k(""), h = k(x), A = k(""), W = k(""), l = a.map((p) => Je({ field: new le(p), locale: u, period: h })), v = new Map(l.map((p) => [p.id, p])), f = ne(() => h.value.value.map((p) => {
    const S = v.get(p);
    if (Qe(S))
      return S;
    throw Error("${fieldId} not found");
  })), y = (p) => {
    if (!p) {
      m.value = ae(a.length);
      return;
    }
    const S = p.split(" ");
    if (S.length !== a.length) {
      c.value = "invalid pattern";
      return;
    }
    for (let w = 0; w < S.length; w++)
      l[w].cron.value != S[w] && (l[w].cron.value = S[w]);
    c.value = "";
  };
  y(s);
  const O = () => {
    m.value = l.map((p) => h.value.value.includes(p.id) || p.cron.value == "?" ? p.cron.value : "*").join(" ");
  }, M = () => {
    A.value = u.getLocaleStr(h.value.id, V.Prefix), W.value = u.getLocaleStr(h.value.id, V.Suffix);
  };
  return M(), g(m, y), g(h, () => {
    O(), M();
  }), l.forEach((p, S) => {
    g(p.cron, () => {
      var w, b;
      (b = (w = a[S]).onChange) == null || b.call(w, p, { segmentMap: v }), O();
    }), g(p.error, (w) => {
      c.value = w;
    });
  }), {
    cron: m,
    error: c,
    segments: l,
    selected: f,
    period: {
      select: (p) => {
        const S = o.map((w) => w.id).indexOf(p);
        S != -1 && (h.value = o[S]);
      },
      selected: h,
      items: o,
      prefix: A,
      suffix: W
    }
  };
}
function Ze(i, { emit: e }) {
  const t = {
    ...i,
    initialValue: i.modelValue,
    initialPeriod: i.period
  }, r = Ge(t);
  return g(
    () => i.modelValue,
    (n) => {
      n && (r.cron.value = n);
    }
  ), g(
    () => i.period,
    (n) => {
      n && r.period.select(n);
    }
  ), g(r.cron, (n) => {
    e("update:model-value", n);
  }), g(r.period.selected, (n) => {
    e("update:period", n.id);
  }), g(r.error, (n) => {
    e("error", n);
  }), r;
}
const _e = () => ({
  /**
   * The value of the cron expression
   *
   * @defaultValue crontab: `* * * * *`, quartz: `* * * * * *`
   */
  modelValue: {
    type: String
  },
  /**
   * The id of a period to select
   *
   * @defaultValue last entry of `CronCoreProps.periods`
   */
  period: {
    type: String
  },
  /**
   * The format of the cron expression, either crontab or quartz
   *
   * @defaultValue `crontab`
   */
  format: {
    type: String
  },
  /**
   * The locale of the component, such as `en`, `de`, etc.
   *
   * @defaultValue `en`
   */
  locale: {
    type: String
  },
  /** The segments of the cron expression, such as second, minute, hour, etc. */
  fields: {
    type: Array
  },
  /** The periods to select, e.g. Every month, day, etc.  */
  periods: {
    type: Array
  },
  /** The custom locale object, used to override values of the current {@link Localization} */
  customLocale: {
    type: Object
  },
  /** Number of columns in the dropdown,
   * e.g. the possible values of minute (0-59) will be displayed in a grid with 5 columns
   *
   * @defaultValue
   * ```
   * {
   *    second: 5,
   *    minute: 5,
   *    hour: 4,
   *    day: 4,
   *  }
   * ```
   */
  cols: {
    type: Object,
    default: () => ({
      second: 5,
      minute: 5,
      hour: 4,
      day: 4
    })
  },
  /** Disable the cron editor */
  disabled: {
    type: Boolean,
    default: !1
  }
}), et = re({
  name: "VueCronCore",
  props: _e(),
  emits: ["update:model-value", "update:period", "error"],
  setup(i, e) {
    const { error: t, selected: r, period: n } = Ze(i, e);
    return () => {
      var s, u;
      const a = {
        error: t,
        fields: r.value.map((o) => ({
          id: o.id,
          items: o.items,
          cron: o.cron.value,
          selectedStr: o.text.value,
          events: {
            "update:model-value": o.select
          },
          attrs: {
            modelValue: o.selected.value
          },
          prefix: o.prefix.value,
          suffix: o.suffix.value
        })),
        period: {
          attrs: {
            modelValue: n.selected.value.id
          },
          events: {
            "update:model-value": n.select
          },
          items: n.items,
          prefix: n.prefix.value,
          suffix: n.suffix.value
        }
      };
      return (u = (s = e.slots).default) == null ? void 0 : u.call(s, a);
    };
  }
});
function tt(i) {
  const { items: e } = i, t = /* @__PURE__ */ new Set(), r = k(0), n = () => {
    r.value = r.value + 1;
  }, a = (c) => {
    e.indexOf(c) != -1 && (t.add(c), n());
  }, s = (c) => t.has(c), u = (c) => {
    t.delete(c) && n();
  };
  return {
    values: t,
    add: a,
    toggle: (c) => {
      s(c) ? u(c) : a(c);
    },
    remove: u,
    clear: () => {
      t.clear(), n();
    },
    updated: r,
    equals: (c) => {
      if (c.length != t.size)
        return !1;
      for (const h of c)
        if (!t.has(h))
          return !1;
      return !0;
    }
  };
}
function rt() {
  return {
    modelValue: {
      type: [String, Number, Array]
    },
    selection: {
      type: String
    },
    clearable: {
      type: Boolean,
      default: !1
    },
    items: {
      type: Array,
      default: () => []
    },
    multiple: {
      type: Boolean,
      default: !1
    },
    cols: {
      type: Number,
      default: 1
    },
    itemText: {
      type: [String, Function],
      default: "text"
    },
    itemValue: {
      type: [String, Function],
      default: "value"
    },
    disabled: {
      type: Boolean,
      default: !1
    }
  };
}
function se(i) {
  const { items: e, cols: t = 1, multiple: r = !1, itemText: n = "text", itemValue: a = "value" } = i, s = tt(i), u = r ? k([]) : k(null), o = k(""), x = (f) => {
    r ? s.toggle(f) : (s.clear(), s.add(f));
  }, m = (f) => {
    if (f === null)
      return !1;
    const y = c(f);
    return Array.isArray(u.value) ? u.value.includes(y) : u.value === y;
  }, c = (f) => typeof a == "function" ? a(f) : f[a], h = (f) => typeof n == "function" ? n(f) : f[n], A = new Map(e.map((f) => [c(f), f])), W = (f) => {
    s.equals(f) || (s.clear(), f.forEach((y) => x(y)));
  }, l = (f) => {
    f = Array.isArray(f) ? f : [f];
    const y = f.map((O) => A.get(O)).filter((O) => !!O);
    W(y);
  };
  g(s.updated, () => {
    const f = Array.from(s.values);
    u.value = r ? f.map(c) : c(f[0]), o.value = f.map(h).join(",");
  });
  const v = ne(() => r ? !Array.isArray(u.value) || u.value.length == 0 : !!u.value);
  return {
    ...s,
    select: x,
    selected: u,
    selectedStr: o,
    itemRows: me(e, t),
    setItems: W,
    setValues: l,
    isEmpty: v,
    has: m
  };
}
function at(i, e, { emit: t }) {
  const r = se(i);
  return g(r.selected, () => {
    t("update:model-value", r.selected.value);
  }), g(
    e,
    (n) => {
      n && r.setValues(n);
    },
    { immediate: !0 }
  ), r;
}
const st = re({
  name: "RenderlessSelect",
  props: {
    ...rt(),
    modelValue: {
      type: [String, Number, Array]
    },
    selection: {
      type: String
    },
    clearable: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["update:modelValue"],
  setup(i, { emit: e, slots: t }) {
    const r = se(i);
    return g(r.selected, () => {
      e("update:modelValue", r.selected.value);
    }), g(
      () => i.modelValue,
      (n) => {
        n && r.setValues(n);
      },
      { immediate: !0 }
    ), () => {
      var a;
      const n = {
        selectedStr: i.selection || r.selectedStr.value,
        modelValue: i.modelValue,
        items: i.items,
        select: r.select,
        isSelected: r.has,
        clearable: i.clearable && !r.isEmpty.value,
        clear: r.clear,
        cols: i.cols,
        rows: r.itemRows.length,
        itemRows: r.itemRows,
        multiple: i.multiple,
        itemText: i.itemText,
        itemValue: i.itemValue
      };
      return (a = t.default) == null ? void 0 : a.call(t, n);
    };
  }
}), ut = {
  install: (i) => {
    i.component("CronCore", et);
  }
};
export {
  et as CronCore,
  ut as CronCorePlugin,
  E as CronType,
  le as FieldWrapper,
  ze as Locale,
  st as RenderlessSelect,
  V as TextPosition,
  _e as cronCoreProps,
  ut as default,
  ce as defaultItems,
  I as genItems,
  Be as getLocale,
  Q as pad,
  rt as selectProps,
  Ze as setupCron,
  at as setupSelect,
  me as splitArray,
  Ge as useCron,
  se as useSelect
};
//# sourceMappingURL=core.js.map
